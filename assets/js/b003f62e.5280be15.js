"use strict";(self.webpackChunk_elizaos_docs=self.webpackChunk_elizaos_docs||[]).push([[74993],{30777:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"core/knowledge","title":"Knowledge System","description":"Understanding ElizaOS knowledge management - how agents process, store, and retrieve information","source":"@site/docs/core/knowledge.md","sourceDirName":"core","slug":"/core/knowledge","permalink":"/docs/core/knowledge","draft":false,"unlisted":false,"editUrl":"https://github.com/elizaos/eliza/tree/develop/packages/docs/docs/core/knowledge.md","tags":[],"version":"current","lastUpdatedBy":"madjin","lastUpdatedAt":1743786825000,"sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Knowledge System","description":"Understanding ElizaOS knowledge management - how agents process, store, and retrieve information","keywords":["knowledge","RAG","embeddings","documents","processing","retrieval","semantic search"],"image":"/img/knowledge.jpg"},"sidebar":"tutorialSidebar","previous":{"title":"Evaluators","permalink":"/docs/core/evaluators"},"next":{"title":"Plugins","permalink":"/docs/core/plugins"}}');var r=i(31085),l=i(71184);const t={sidebar_position:4,title:"Knowledge System",description:"Understanding ElizaOS knowledge management - how agents process, store, and retrieve information",keywords:["knowledge","RAG","embeddings","documents","processing","retrieval","semantic search"],image:"/img/knowledge.jpg"},d="Knowledge Management",o={},a=[{value:"Overview",id:"overview",level:2},{value:"Adding Knowledge to Agents",id:"adding-knowledge-to-agents",level:2},{value:"Adding Knowledge During Runtime Creation",id:"adding-knowledge-during-runtime-creation",level:3},{value:"1. Via Character Definition",id:"1-via-character-definition",level:4},{value:"2. Programmatically Before Runtime Initialization",id:"2-programmatically-before-runtime-initialization",level:4},{value:"Adding Knowledge After Runtime Creation",id:"adding-knowledge-after-runtime-creation",level:3},{value:"1. Using the <code>addKnowledge</code> Method",id:"1-using-the-addknowledge-method",level:4},{value:"2. Processing Files at Runtime",id:"2-processing-files-at-runtime",level:4},{value:"Directory Structure",id:"directory-structure",level:2},{value:"Supported File Types",id:"supported-file-types",level:2},{value:"Knowledge Modes",id:"knowledge-modes",level:2},{value:"Classic Mode (Default)",id:"classic-mode-default",level:3},{value:"RAG Mode",id:"rag-mode",level:3},{value:"How Knowledge Processing Works",id:"how-knowledge-processing-works",level:2},{value:"Document Processing Flow",id:"document-processing-flow",level:3},{value:"Knowledge Processing Flow Diagram",id:"knowledge-processing-flow-diagram",level:3},{value:"Processing Parameters",id:"processing-parameters",level:3},{value:"Best Practices for Knowledge Management",id:"best-practices-for-knowledge-management",level:2},{value:"Content Organization",id:"content-organization",level:3},{value:"Processing Large Knowledge Bases",id:"processing-large-knowledge-bases",level:3},{value:"Knowledge ID Management",id:"knowledge-id-management",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Issues and Solutions",id:"common-issues-and-solutions",level:3},{value:"Technical Implementation Details",id:"technical-implementation-details",level:2},{value:"Knowledge ID Relationships",id:"knowledge-id-relationships",level:3},{value:"ID Generation and Linking",id:"id-generation-and-linking",level:4},{value:"API Reference",id:"api-reference",level:2},{value:"Key Methods",id:"key-methods",level:3},{value:"<code>runtime.addKnowledge(item: KnowledgeItem, options?): Promise&lt;void&gt;</code>",id:"runtimeaddknowledgeitem-knowledgeitem-options-promisevoid",level:4},{value:"<code>runtime.getKnowledge(message: Memory): Promise&lt;KnowledgeItem[]&gt;</code>",id:"runtimegetknowledgemessage-memory-promiseknowledgeitem",level:4},{value:"Knowledge Item Definition",id:"knowledge-item-definition",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Future Considerations",id:"future-considerations",level:2},{value:"Support and Resources",id:"support-and-resources",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"knowledge-management",children:"Knowledge Management"})}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"The Knowledge Management system in ElizaOS is a powerful Retrieval-Augmented Generation (RAG) feature that enables agents to process, store, and retrieve information from various sources. This allows agents to provide contextually relevant responses by leveraging stored knowledge during conversations."}),"\n",(0,r.jsx)(n.h2,{id:"adding-knowledge-to-agents",children:"Adding Knowledge to Agents"}),"\n",(0,r.jsx)(n.p,{children:"ElizaOS provides multiple ways to add knowledge to your agents, both during initialization and at runtime."}),"\n",(0,r.jsx)(n.h3,{id:"adding-knowledge-during-runtime-creation",children:"Adding Knowledge During Runtime Creation"}),"\n",(0,r.jsx)(n.h4,{id:"1-via-character-definition",children:"1. Via Character Definition"}),"\n",(0,r.jsx)(n.p,{children:"The simplest approach is to define knowledge directly in your character configuration:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const character: Character = {\n  name: 'My Agent',\n  // Other character properties...\n  knowledge: [\n    // Direct string knowledge\n    'Important fact: ElizaOS supports multiple knowledge formats',\n\n    // File references\n    { path: 'knowledge/documentation.md', shared: false },\n\n    // Directory references\n    { directory: 'knowledge/guides', shared: true },\n  ],\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:"The knowledge array supports three formats:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"String literals for direct knowledge"}),"\n",(0,r.jsx)(n.li,{children:"File objects pointing to specific files"}),"\n",(0,r.jsx)(n.li,{children:"Directory objects for entire folders of content"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"2-programmatically-before-runtime-initialization",children:"2. Programmatically Before Runtime Initialization"}),"\n",(0,r.jsx)(n.p,{children:"You can dynamically load knowledge before creating your runtime:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Load knowledge from files or other sources\nconst knowledge = [];\n\n// Example: Recursively load documentation files\nfunction loadDocumentation(directoryPath) {\n  const files = getFilesRecursively(directoryPath, ['.md']);\n  return files.map((filePath) => {\n    const relativePath = path.relative(basePath, filePath);\n    const content = fs.readFileSync(filePath, 'utf-8');\n    return `Path: ${relativePath}\\n\\n${content}`;\n  });\n}\n\n// Load documentation\nconst docKnowledge = loadDocumentation('./docs');\nknowledge.push(...docKnowledge);\n\n// Then include in your character definition\nconst character: Character = {\n  // Other character properties...\n  knowledge: knowledge,\n};\n"})}),"\n",(0,r.jsx)(n.h3,{id:"adding-knowledge-after-runtime-creation",children:"Adding Knowledge After Runtime Creation"}),"\n",(0,r.jsxs)(n.h4,{id:"1-using-the-addknowledge-method",children:["1. Using the ",(0,r.jsx)(n.code,{children:"addKnowledge"})," Method"]}),"\n",(0,r.jsx)(n.p,{children:"Add knowledge programmatically after the runtime is initialized:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Import needed utilities\nimport { createUniqueUuid } from '@elizaos/core';\n\n// Create a knowledge item\nconst knowledgeItem = {\n  id: createUniqueUuid(runtime, 'unique-knowledge-identifier'),\n  content: {\n    text: 'Important information the agent should know...',\n  },\n};\n\n// Add to runtime with default chunking settings\nawait runtime.addKnowledge(knowledgeItem);\n\n// Or with custom chunking settings\nawait runtime.addKnowledge(knowledgeItem, {\n  targetTokens: 1500, // Target chunk size (default: 3000)\n  overlap: 100, // Overlap between chunks (default: 200)\n  modelContextSize: 8192, // Context size of your model (default: 4096)\n});\n"})}),"\n",(0,r.jsx)(n.h4,{id:"2-processing-files-at-runtime",children:"2. Processing Files at Runtime"}),"\n",(0,r.jsx)(n.p,{children:"You can dynamically process files at runtime:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// For PDF files, use the PDF service\nconst pdfService = runtime.getService<IPdfService>('pdf');\nif (pdfService) {\n  const pdfBuffer = fs.readFileSync('./knowledge/document.pdf');\n  const textContent = await pdfService.convertPdfToText(pdfBuffer);\n\n  const knowledgeItem = {\n    id: createUniqueUuid(runtime, 'document.pdf'),\n    content: { text: textContent },\n  };\n\n  await runtime.addKnowledge(knowledgeItem);\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"directory-structure",children:"Directory Structure"}),"\n",(0,r.jsx)(n.p,{children:"ElizaOS expects knowledge files to be organized in the following structure:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"knowledge/          # Root knowledge directory\n\u251c\u2500\u2500 shared/         # Shared knowledge accessible to all agents\n\u2514\u2500\u2500 {agent-name}/   # Agent-specific knowledge directories\n"})}),"\n",(0,r.jsx)(n.h2,{id:"supported-file-types",children:"Supported File Types"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["PDF files (",(0,r.jsx)(n.code,{children:".pdf"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["Markdown files (",(0,r.jsx)(n.code,{children:".md"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["Text files (",(0,r.jsx)(n.code,{children:".txt"}),")"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"knowledge-modes",children:"Knowledge Modes"}),"\n",(0,r.jsx)(n.p,{children:"ElizaOS supports two knowledge modes:"}),"\n",(0,r.jsx)(n.h3,{id:"classic-mode-default",children:"Classic Mode (Default)"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Direct string knowledge added to character's context"}),"\n",(0,r.jsx)(n.li,{children:"No chunking or semantic search"}),"\n",(0,r.jsxs)(n.li,{children:["Enabled by default (",(0,r.jsx)(n.code,{children:"settings.ragKnowledge: false"}),")"]}),"\n",(0,r.jsx)(n.li,{children:"Only processes string knowledge entries"}),"\n",(0,r.jsx)(n.li,{children:"Simpler but less sophisticated"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"rag-mode",children:"RAG Mode"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Advanced knowledge processing with semantic search"}),"\n",(0,r.jsx)(n.li,{children:"Chunks content and uses embeddings"}),"\n",(0,r.jsxs)(n.li,{children:["Must be explicitly enabled (",(0,r.jsx)(n.code,{children:"settings.ragKnowledge: true"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["Supports three knowledge types:","\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Direct string knowledge"}),"\n",(0,r.jsxs)(n.li,{children:["Single file references: ",(0,r.jsx)(n.code,{children:'{ "path": "path/to/file.md", "shared": false }'})]}),"\n",(0,r.jsxs)(n.li,{children:["Directory references: ",(0,r.jsx)(n.code,{children:'{ "directory": "knowledge/dir", "shared": false }'})]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:"Supported file types: .md, .txt, .pdf"}),"\n",(0,r.jsxs)(n.li,{children:["Optional ",(0,r.jsx)(n.code,{children:"shared"})," flag for knowledge reuse across characters"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"To enable RAG mode, add this to your character settings:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const character: Character = {\n  // Other character properties...\n  settings: {\n    ragKnowledge: true,\n  },\n};\n"})}),"\n",(0,r.jsx)(n.h2,{id:"how-knowledge-processing-works",children:"How Knowledge Processing Works"}),"\n",(0,r.jsx)(n.h3,{id:"document-processing-flow",children:"Document Processing Flow"}),"\n",(0,r.jsx)(n.p,{children:"The RAG system processes documents through several stages:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Directory Processing"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The system scans configured directories in ",(0,r.jsx)(n.code,{children:"knowledge/"})]}),"\n",(0,r.jsx)(n.li,{children:"Files are processed based on their shared/private status and file type"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"File Processing Pipeline"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Preprocessing"}),": Reading, cleaning, and normalizing text"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Document-level Processing"}),": Generating embeddings for the entire document"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Chunk Processing"}),": Splitting content into manageable chunks and generating embeddings for each"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Retrieval Process"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"When a user message is received, its embedding is generated"}),"\n",(0,r.jsx)(n.li,{children:"This embedding is compared to stored knowledge embeddings"}),"\n",(0,r.jsx)(n.li,{children:"The most semantically similar chunks are retrieved"}),"\n",(0,r.jsx)(n.li,{children:"Retrieved knowledge is incorporated into the agent's context"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This multi-level approach enables:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Broad document-level semantic search"}),"\n",(0,r.jsx)(n.li,{children:"Fine-grained chunk-level retrieval for specific information"}),"\n",(0,r.jsx)(n.li,{children:"Efficient parallel processing of large documents"}),"\n",(0,r.jsx)(n.li,{children:"Maintenance of document context through metadata linking"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"knowledge-processing-flow-diagram",children:"Knowledge Processing Flow Diagram"}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TB\n    subgraph Directory_Processing\n        A[Read Files from Directory] --\x3e B[File Content]\n    end\n\n    subgraph Preprocessing\n        B --\x3e C[Clean & Normalize Text]\n    end\n\n    subgraph Document_Processing\n        C --\x3e D[Generate Document Embedding]\n        D --\x3e E[Store Full Document]\n        E --\x3e |Metadata| F[File Path]\n        E --\x3e |Metadata| G[File Type]\n        E --\x3e |Metadata| H[Shared Status]\n    end\n\n    subgraph Chunk_Processing\n        C --\x3e I[Split into Chunks]\n        I --\x3e |512 tokens| J[Chunk 1]\n        I --\x3e |20 token overlap| K[...]\n        I --\x3e L[Chunk N]\n\n        subgraph Parallel_Processing\n            J --\x3e M1[Generate Embedding]\n            K --\x3e M2[Generate Embedding]\n            L --\x3e M3[Generate Embedding]\n        end\n\n        subgraph Chunk_Storage\n            M1 --\x3e N1[Store Chunk]\n            M2 --\x3e N2[Store Chunk]\n            M3 --\x3e N3[Store Chunk]\n\n            N1 --\x3e |Metadata| O[Original Doc Reference]\n            N1 --\x3e |Metadata| P[Chunk Index]\n            N2 --\x3e |Metadata| O\n            N2 --\x3e |Metadata| P\n            N3 --\x3e |Metadata| O\n            N3 --\x3e |Metadata| P\n        end\n    end\n\n    style Directory_Processing fill:#f9f,stroke:#333,stroke-width:2px\n    style Preprocessing fill:#bbf,stroke:#333,stroke-width:2px\n    style Document_Processing fill:#bfb,stroke:#333,stroke-width:2px\n    style Chunk_Processing fill:#fbf,stroke:#333,stroke-width:2px\n    style Parallel_Processing fill:#fbb,stroke:#333,stroke-width:2px\n    style Chunk_Storage fill:#bff,stroke:#333,stroke-width:2px"}),"\n",(0,r.jsx)(n.h3,{id:"processing-parameters",children:"Processing Parameters"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Chunk Size"}),": 512 tokens (default, configurable when adding knowledge)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Chunk Overlap"}),": 20 tokens (default, configurable)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Processing Batch Size"}),": 10 chunks processed concurrently"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Default Similarity Threshold"}),": 0.85 for retrieval"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Default Match Count"}),": 5 results returned"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"best-practices-for-knowledge-management",children:"Best Practices for Knowledge Management"}),"\n",(0,r.jsx)(n.h3,{id:"content-organization",children:"Content Organization"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Document Structure"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Use clear section headings and hierarchical organization"}),"\n",(0,r.jsx)(n.li,{children:"Break large documents into logical smaller files"}),"\n",(0,r.jsx)(n.li,{children:"Include metadata and context in markdown files"}),"\n",(0,r.jsx)(n.li,{children:"Structure information from general to specific"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"File Management"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Use descriptive filenames that reflect content"}),"\n",(0,r.jsx)(n.li,{children:"Group related files in subdirectories"}),"\n",(0,r.jsx)(n.li,{children:"Keep paths short and meaningful"}),"\n",(0,r.jsx)(n.li,{children:"Avoid special characters in filenames"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Knowledge Optimization"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Keep individual documents focused on specific topics"}),"\n",(0,r.jsxs)(n.li,{children:["For very detailed information, use smaller chunks (200-300 tokens) by setting ",(0,r.jsx)(n.code,{children:"targetTokens"})]}),"\n",(0,r.jsx)(n.li,{children:"Balance the total number of knowledge items for performance"}),"\n",(0,r.jsx)(n.li,{children:"Prefer markdown (.md) files for best processing results"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"processing-large-knowledge-bases",children:"Processing Large Knowledge Bases"}),"\n",(0,r.jsx)(n.p,{children:"When adding many knowledge items at once, consider implementing a semaphore pattern:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { Semaphore } from '@elizaos/core';\n\n// Create semaphore to limit concurrent processing\nconst semaphore = new Semaphore(10);\n\n// Process items with controlled concurrency\nawait Promise.all(\n  items.map(async (item) => {\n    await semaphore.acquire();\n    try {\n      await runtime.addKnowledge(item);\n    } finally {\n      semaphore.release();\n    }\n  })\n);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"knowledge-id-management",children:"Knowledge ID Management"}),"\n",(0,r.jsx)(n.p,{children:"When adding knowledge programmatically, use consistent ID generation:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { createUniqueUuid } from '@elizaos/core';\nconst knowledgeId = createUniqueUuid(runtime, 'my-content');\n"})}),"\n",(0,r.jsx)(n.p,{children:"This ensures deterministic IDs that remain stable across sessions."}),"\n",(0,r.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,r.jsx)(n.h3,{id:"common-issues-and-solutions",children:"Common Issues and Solutions"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Knowledge Not Being Retrieved"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Verify the file is in a supported format (PDF, MD, TXT)"}),"\n",(0,r.jsx)(n.li,{children:"Check if embeddings were properly generated"}),"\n",(0,r.jsx)(n.li,{children:"Ensure similarity threshold isn't too high (default: 0.85)"}),"\n",(0,r.jsx)(n.li,{children:"Test retrieval with more specific queries"}),"\n",(0,r.jsx)(n.li,{children:"Verify RAG mode is enabled if using file/directory references"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Poor Quality Retrievals"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Break down large documents into smaller, focused files"}),"\n",(0,r.jsx)(n.li,{children:"Ensure document content is clear and well-structured"}),"\n",(0,r.jsx)(n.li,{children:"Review the chunking size and overlap settings"}),"\n",(0,r.jsx)(n.li,{children:"Check if the query contains too many common words"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Performance Issues"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Monitor the total number of knowledge items"}),"\n",(0,r.jsx)(n.li,{children:"Consider reducing the match count for faster retrieval"}),"\n",(0,r.jsx)(n.li,{children:"Check embedding processing time for large documents"}),"\n",(0,r.jsx)(n.li,{children:"Use shared knowledge efficiently across agents"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"File Processing Errors"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Verify file permissions"}),"\n",(0,r.jsx)(n.li,{children:"Check if paths are correctly structured"}),"\n",(0,r.jsx)(n.li,{children:"Ensure PDF files are readable and not password-protected"}),"\n",(0,r.jsx)(n.li,{children:"Validate that text encoding is UTF-8"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"technical-implementation-details",children:"Technical Implementation Details"}),"\n",(0,r.jsx)(n.h3,{id:"knowledge-id-relationships",children:"Knowledge ID Relationships"}),"\n",(0,r.jsx)(n.p,{children:"The RAG system uses a hierarchical ID structure to maintain relationships:"}),"\n",(0,r.jsx)(n.mermaid,{value:'classDiagram\n    class Document {\n        +UUID id\n        +String filePath\n        +String fileType\n        +Boolean isShared\n        +Float32Array embedding\n        +String content\n    }\n\n    class Fragment {\n        +UUID id\n        +UUID originalId\n        +Number chunkIndex\n        +String content\n        +Float32Array embedding\n        +String originalPath\n    }\n\n    Document "1" --\x3e "*" Fragment : generates'}),"\n",(0,r.jsx)(n.h4,{id:"id-generation-and-linking",children:"ID Generation and Linking"}),"\n",(0,r.jsxs)(n.p,{children:["Documents IDs are generated using ",(0,r.jsx)(n.code,{children:"createUniqueUuid(runtime, path, isShared)"}),", making them deterministic. Fragment IDs follow the format ",(0,r.jsx)(n.code,{children:"${documentId}-chunk-${index}"})," to maintain the relationship to their source document."]}),"\n",(0,r.jsx)(n.h2,{id:"api-reference",children:"API Reference"}),"\n",(0,r.jsx)(n.h3,{id:"key-methods",children:"Key Methods"}),"\n",(0,r.jsx)(n.h4,{id:"runtimeaddknowledgeitem-knowledgeitem-options-promisevoid",children:(0,r.jsx)(n.code,{children:"runtime.addKnowledge(item: KnowledgeItem, options?): Promise<void>"})}),"\n",(0,r.jsx)(n.p,{children:"Adds new knowledge to the agent."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Parameters:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"item"}),": A knowledge item containing:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"id"}),": UUID"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"content"}),": Object with ",(0,r.jsx)(n.code,{children:"text"})," property"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"options"}),": Optional processing configuration:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"targetTokens"}),": Number (default: 3000)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"overlap"}),": Number (default: 200)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"modelContextSize"}),": Number (default: 4096)"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"runtimegetknowledgemessage-memory-promiseknowledgeitem",children:(0,r.jsx)(n.code,{children:"runtime.getKnowledge(message: Memory): Promise<KnowledgeItem[]>"})}),"\n",(0,r.jsx)(n.p,{children:"Retrieves knowledge based on a message's content."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Parameters:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"message"}),": Memory object containing user message"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:"Returns: Array of matching KnowledgeItem objects"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"knowledge-item-definition",children:"Knowledge Item Definition"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface KnowledgeItem {\n  id: UUID;\n  content: {\n    text: string;\n    // Optional additional metadata\n    [key: string]: any;\n  };\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Access Control"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use the ",(0,r.jsx)(n.code,{children:"shared"})," flag appropriately to control document access"]}),"\n",(0,r.jsx)(n.li,{children:"Keep sensitive information in agent-specific directories"}),"\n",(0,r.jsx)(n.li,{children:"Regularly audit knowledge access patterns"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Data Privacy"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Do not store sensitive personal information in knowledge files"}),"\n",(0,r.jsx)(n.li,{children:"Review documents for potentially sensitive content before adding"}),"\n",(0,r.jsx)(n.li,{children:"Implement appropriate backup and recovery procedures"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"future-considerations",children:"Future Considerations"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Scalability"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Monitor knowledge base size and performance"}),"\n",(0,r.jsx)(n.li,{children:"Plan for regular maintenance and cleanup"}),"\n",(0,r.jsx)(n.li,{children:"Consider implementing document versioning"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Integration"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Document integration points with other systems"}),"\n",(0,r.jsx)(n.li,{children:"Plan for potential future file format support"}),"\n",(0,r.jsx)(n.li,{children:"Consider implementing knowledge base analytics"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"support-and-resources",children:"Support and Resources"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Review the implementation in ",(0,r.jsx)(n.code,{children:"packages/core/src/ragknowledge.ts"})]}),"\n",(0,r.jsx)(n.li,{children:"Check the issue tracker for known issues and solutions"}),"\n",(0,r.jsx)(n.li,{children:"Contribute improvements and bug fixes through pull requests"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},71184:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>d});var s=i(14041);const r={},l=s.createContext(r);function t(e){const n=s.useContext(l);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),s.createElement(l.Provider,{value:n},e.children)}}}]);